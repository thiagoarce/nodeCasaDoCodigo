var componentsUtil = require("./util");
var componentLookup = componentsUtil.h_;
var emitLifecycleEvent = componentsUtil.F_;

var ComponentsContext = require("./ComponentsContext");
var getComponentsContext = ComponentsContext.E_;
var registry = require("./registry");
var copyProps = require("raptor-util/copyProps");
var isServer = componentsUtil.ay_ === true;
var beginComponent = require("./beginComponent");
var endComponent = require("./endComponent");

var COMPONENT_BEGIN_ASYNC_ADDED_KEY = "$wa";

function resolveComponentKey(key, parentComponentDef) {
    if (key[0] === "#") {
        return key.substring(1);
    } else {
        return parentComponentDef.id + "-" + parentComponentDef.c_(key);
    }
}

function trackAsyncComponents(out) {
    if (out.isSync() || out.global[COMPONENT_BEGIN_ASYNC_ADDED_KEY]) {
        return;
    }

    out.on("beginAsync", handleBeginAsync);
    out.on("beginDetachedAsync", handleBeginDetachedAsync);
    out.global[COMPONENT_BEGIN_ASYNC_ADDED_KEY] = true;
}

function handleBeginAsync(event) {
    var parentOut = event.parentOut;
    var asyncOut = event.out;
    var componentsContext = parentOut.i_;

    if (componentsContext !== undefined) {
        // We are going to start a nested ComponentsContext
        asyncOut.i_ = new ComponentsContext(asyncOut, componentsContext);
    }
    // Carry along the component arguments
    asyncOut.c(parentOut.l_, parentOut.ao_, parentOut.ax_);
}

function handleBeginDetachedAsync(event) {
    var asyncOut = event.out;
    handleBeginAsync(event);
    asyncOut.on("beginAsync", handleBeginAsync);
    asyncOut.on("beginDetachedAsync", handleBeginDetachedAsync);
}

function createRendererFunc(templateRenderFunc, componentProps, renderingLogic) {
    renderingLogic = renderingLogic || {};
    var onInput = renderingLogic.onInput;
    var typeName = componentProps.f_;
    var isSplit = componentProps.d_ === true;
    var isImplicitComponent = componentProps.e_ === true;

    var shouldApplySplitMixins = isSplit;

    return function renderer(input, out) {
        trackAsyncComponents(out);

        var componentsContext = getComponentsContext(out);
        var globalComponentsContext = componentsContext.m_;

        var component = globalComponentsContext._r_;
        var isRerender = component !== undefined;
        var id;
        var isExisting;
        var customEvents;
        var parentComponentDef = componentsContext.j_;
        var ownerComponentDef = out.l_;
        var ownerComponentId = ownerComponentDef && ownerComponentDef.id;
        var key = out.ao_;

        if (component) {
            // If component is provided then we are currently rendering
            // the top-level UI component as part of a re-render
            id = component.id; // We will use the ID of the component being re-rendered
            isExisting = true; // This is a re-render so we know the component is already in the DOM
            globalComponentsContext._r_ = null;
        } else {
            // Otherwise, we are rendering a nested UI component. We will need
            // to match up the UI component with the component already in the
            // DOM (if any) so we will need to resolve the component ID from
            // the assigned key. We also need to handle any custom event bindings
            // that were provided.
            if (parentComponentDef) {
                // console.log('componentArgs:', componentArgs);
                customEvents = out.ax_;

                if (key != null) {
                    id = resolveComponentKey(key.toString(), parentComponentDef);
                } else {
                    id = parentComponentDef._I_();
                }
            } else {
                id = globalComponentsContext._I_();
            }
        }

        if (isServer) {
            // If we are rendering on the server then things are simplier since
            // we don't need to match up the UI component with a previously
            // rendered component already mounted to the DOM. We also create
            // a lightweight ServerComponent
            component = registry._K_(renderingLogic, id, input, out, typeName, customEvents, ownerComponentId);

            // This is the final input after running the lifecycle methods.
            // We will be passing the input to the template for the `input` param
            input = component._S_;

            component._S_ = undefined; // We don't want ___updatedInput to be serialized to the browser
        } else {
            if (!component) {
                if (isRerender && (component = componentLookup[id]) && component.f_ !== typeName) {
                    // Destroy the existing component since
                    component.destroy();
                    component = undefined;
                }

                if (component) {
                    isExisting = true;
                } else {
                    isExisting = false;
                    // We need to create a new instance of the component
                    component = registry._K_(typeName, id);

                    if (shouldApplySplitMixins === true) {
                        shouldApplySplitMixins = false;

                        var renderingLogicProps = typeof renderingLogic == "function" ? renderingLogic.prototype : renderingLogic;

                        copyProps(renderingLogicProps, component.constructor.prototype);
                    }
                }

                // Set this flag to prevent the component from being queued for update
                // based on the new input. The component is about to be rerendered
                // so we don't want to queue it up as a result of calling `setInput()`
                component.V_ = true;

                if (customEvents !== undefined) {
                    component._w_(customEvents, ownerComponentId);
                }

                if (isExisting === false) {
                    emitLifecycleEvent(component, "create", input, out);
                }

                input = component._h_(input, onInput, out);

                if (isExisting === true) {
                    if (component._k_ === false || component.shouldUpdate(input, component.K_) === false) {
                        // We put a placeholder element in the output stream to ensure that the existing
                        // DOM node is matched up correctly when using morphdom. We flag the VElement
                        // node to track that it is a preserve marker
                        out.q_(component);
                        globalComponentsContext.r_[id] = true;
                        component.J_(); // The component is no longer dirty so reset internal flags
                        return;
                    }
                }
            }

            component.T_ = out.global;

            emitLifecycleEvent(component, "render", out);
        }

        var componentDef = beginComponent(componentsContext, component, key, ownerComponentDef, isSplit, isImplicitComponent);

        componentDef._D_ = isExisting;

        // Render the template associated with the component using the final template
        // data that we constructed
        templateRenderFunc(input, out, componentDef, component, component._u_);

        endComponent(out, componentDef);
        componentsContext.j_ = parentComponentDef;
    };
}

module.exports = createRendererFunc;

// exports used by the legacy renderer
createRendererFunc.al_ = resolveComponentKey;
createRendererFunc.aw_ = trackAsyncComponents;